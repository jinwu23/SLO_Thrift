import os
import dotenv
import sqlalchemy
from faker import Faker
import numpy as np
import random

# gets local database_connection_url from .env
def database_connection_url():
    dotenv.load_dotenv()
    return os.environ.get("LOCAL_POSTGRES_URL")

# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS replies;
    DROP TABLE IF EXISTS reviews;
    DROP TABLE IF EXISTS stores;

    CREATE TABLE 
        stores (
            id bigint generated by default as identity,
            created_at timestamp with time zone not null default now(),
            name text null,
            address text null,
            type text null,
            version integer null default 1,
            constraint stores_pkey primary key (id)
        );

    CREATE TABLE
    reviews (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        account_name text not null,
        rating smallint not null,
        description text null,
        store_id bigint not null,
        constraint reviews_pkey primary key (id),
        constraint reviews_store_id_fkey foreign key (store_id) references stores (id) on delete cascade,
        constraint reviews_rating_check check (
        (
            (rating >= 0)
            and (rating <= 5)
        )
        )
    );    
        
    CREATE TABLE
    replies (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        review_id bigint not null,
        account_name text not null,
        description text not null,
        constraint replies_pkey primary key (id),
        constraint replies_review_id_fkey foreign key (review_id) references reviews (id) on delete cascade
    );
    """))

num_stores = 1000
reviews_per_store = 100
replies_per_review = 10
fake = Faker() 

# create fake stores with name, address, type and version
with engine.begin() as conn:
    print("creating fake data")
    types = ["clothes", "furniture", "misc", "outdoors", "streetware", "athletic", "casual", "formal"]

    for i in range(num_stores):
        print("store number: " + str(i))
        fake_name = fake.company()
        fake_address = fake.address()
        fake_type = random.choice(types)
        
        store_id = conn.execute(sqlalchemy.text("""
        INSERT INTO stores (name, address, type)
        VALUES (:name, :address, :type)
        RETURNING id;
        """), {"name": fake_name, "address": fake_address, "type": fake_type}).scalar_one()

        # create fake reviews for store with account_name, rating, description
        for i in range(reviews_per_store):
            fake_name = fake.name()
            fake_rating = random.randint(0, 5)
            fake_description = fake.text()

            review_id = conn.execute(sqlalchemy.text("""
            INSERT INTO reviews (account_name, rating, description, store_id)
            VALUES (:account_name, :rating, :description, :store_id)
            RETURNING id;
            """), {"account_name": fake_name, "rating": fake_rating, "description": fake_description, "store_id": store_id}).scalar_one()

            # create fake replies for each review with review_id, account_name, description
            for i in range(replies_per_review):
                fake_name = fake.name()
                fake_description = fake.text()

                reply_id = conn.execute(sqlalchemy.text("""
                INSERT INTO replies (review_id, account_name, description)
                VALUES (:review_id, :account_name, :description)
                RETURNING id;
                """), {"review_id": review_id, "account_name": fake_name, "description": fake_description}).scalar_one()
